<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Beam with Point Load</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        #canvas {
            width: 100%;
            height: 400px;
            border: 2px solid #ddd;
            border-radius: 10px;
            background: #f9f9f9;
            display: block;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .control-group {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
        }
        
        .control-group h3 {
            margin: 0 0 15px 0;
            color: #444;
            font-size: 16px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }
        
        .control-item {
            margin: 12px 0;
        }
        
        .control-item label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-size: 14px;
            font-weight: bold;
        }
        
        .control-item input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        .control-item select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        
        .value-display {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 13px;
            margin-left: 10px;
        }
        
        .results {
            margin-top: 30px;
            background: #e8f4f8;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .results h3 {
            margin: 0 0 15px 0;
            color: #333;
        }
        
        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .result-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .result-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .result-value {
            font-size: 18px;
            font-weight: bold;
            color: #667eea;
        }
        
        .result-unit {
            font-size: 12px;
            color: #888;
            margin-left: 3px;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #555;
        }
        
        .legend-color {
            width: 30px;
            height: 15px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Simple Beam with Point Load</h1>
        <p class="subtitle">Interactive structural analysis visualization</p>
        
        <canvas id="canvas"></canvas>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #333;"></div>
                <span>Original Beam</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #e74c3c;"></div>
                <span>Deflected Shape (Exaggerated)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #e67e22;"></div>
                <span>Point Load</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #27ae60;"></div>
                <span>Reactions</span>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h3>Load Parameters</h3>
                <div class="control-item">
                    <label>
                        Point Load (P): <span class="value-display" id="loadValue">10 kN</span>
                    </label>
                    <input type="range" id="loadInput" min="1" max="50" step="1" value="10">
                </div>
                <div class="control-item">
                    <label>
                        Load Position: <span class="value-display" id="positionValue">50%</span>
                    </label>
                    <input type="range" id="positionInput" min="10" max="90" step="5" value="50">
                </div>
            </div>
            
            <div class="control-group">
                <h3>Beam Properties</h3>
                <div class="control-item">
                    <label>
                        Length (L): <span class="value-display" id="lengthValue">6 m</span>
                    </label>
                    <input type="range" id="lengthInput" min="3" max="12" step="0.5" value="6">
                </div>
                <div class="control-item">
                    <label>Support Type:</label>
                    <select id="supportType">
                        <option value="simple">Simply Supported</option>
                        <option value="cantilever">Cantilever</option>
                    </select>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Material & Section</h3>
                <div class="control-item">
                    <label>
                        E (Modulus): <span class="value-display" id="eValue">200 GPa</span>
                    </label>
                    <input type="range" id="eInput" min="50" max="300" step="10" value="200">
                </div>
                <div class="control-item">
                    <label>
                        I (Moment of Inertia): <span class="value-display" id="iValue">100 cm⁴</span>
                    </label>
                    <input type="range" id="iInput" min="50" max="500" step="10" value="100">
                </div>
            </div>
        </div>
        
        <div class="results">
            <h3>Analysis Results</h3>
            <div class="result-grid">
                <div class="result-item">
                    <div class="result-label">Left Reaction (R₁)</div>
                    <div class="result-value"><span id="r1Result">0</span><span class="result-unit">kN</span></div>
                </div>
                <div class="result-item">
                    <div class="result-label">Right Reaction (R₂)</div>
                    <div class="result-value"><span id="r2Result">0</span><span class="result-unit">kN</span></div>
                </div>
                <div class="result-item">
                    <div class="result-label">Max Moment</div>
                    <div class="result-value"><span id="maxMoment">0</span><span class="result-unit">kN·m</span></div>
                </div>
                <div class="result-item">
                    <div class="result-label">Max Deflection</div>
                    <div class="result-value"><span id="maxDeflection">0</span><span class="result-unit">mm</span></div>
                </div>
                <div class="result-item">
                    <div class="result-label">Shear at Load</div>
                    <div class="result-value"><span id="shearLoad">0</span><span class="result-unit">kN</span></div>
                </div>
                <div class="result-item">
                    <div class="result-label">Deflection at Load</div>
                    <div class="result-value"><span id="deflectionLoad">0</span><span class="result-unit">mm</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            drawBeam();
        }
        
        // Parameters
        let P = 10; // Load in kN
        let L = 6; // Length in m
        let loadPosition = 0.5; // Position as fraction of L (0 to 1)
        let E = 200; // Young's modulus in GPa
        let I = 100; // Moment of inertia in cm^4
        let supportType = 'simple';
        
        // Get controls
        const loadInput = document.getElementById('loadInput');
        const positionInput = document.getElementById('positionInput');
        const lengthInput = document.getElementById('lengthInput');
        const eInput = document.getElementById('eInput');
        const iInput = document.getElementById('iInput');
        const supportTypeSelect = document.getElementById('supportType');
        
        // Update functions
        loadInput.addEventListener('input', (e) => {
            P = parseFloat(e.target.value);
            document.getElementById('loadValue').textContent = P + ' kN';
            drawBeam();
        });
        
        positionInput.addEventListener('input', (e) => {
            loadPosition = parseFloat(e.target.value) / 100;
            document.getElementById('positionValue').textContent = e.target.value + '%';
            drawBeam();
        });
        
        lengthInput.addEventListener('input', (e) => {
            L = parseFloat(e.target.value);
            document.getElementById('lengthValue').textContent = L + ' m';
            drawBeam();
        });
        
        eInput.addEventListener('input', (e) => {
            E = parseFloat(e.target.value);
            document.getElementById('eValue').textContent = E + ' GPa';
            drawBeam();
        });
        
        iInput.addEventListener('input', (e) => {
            I = parseFloat(e.target.value);
            document.getElementById('iValue').textContent = I + ' cm⁴';
            drawBeam();
        });
        
        supportTypeSelect.addEventListener('change', (e) => {
            supportType = e.target.value;
            drawBeam();
        });
        
        // Calculate reactions and moments
        function calculateReactions() {
            const a = loadPosition * L; // Distance from left support to load
            const b = L - a; // Distance from load to right support
            
            if (supportType === 'simple') {
                // Simply supported beam
                const R1 = (P * b) / L; // Left reaction
                const R2 = (P * a) / L; // Right reaction
                const M_max = (P * a * b) / L; // Maximum moment at load point
                
                return { R1, R2, M_max };
            } else {
                // Cantilever beam (fixed at left, load at distance a)
                const R1 = P; // Reaction at fixed end
                const R2 = 0; // No right support
                const M_max = P * a; // Maximum moment at fixed end
                
                return { R1, R2, M_max };
            }
        }
        
        // Calculate deflection at a point x along the beam
        function calculateDeflection(x) {
            const a = loadPosition * L;
            const EI = E * 1e6 * I * 1e-8; // Convert to kN·m²
            
            if (supportType === 'simple') {
                const b = L - a;
                let delta;
                
                if (x <= a) {
                    // Before the load
                    delta = (P * b * x) / (6 * L * EI) * (L * L - b * b - x * x);
                } else {
                    // After the load
                    delta = (P * a * (L - x)) / (6 * L * EI) * (L * L - a * a - (L - x) * (L - x));
                }
                
                return delta * 1000; // Convert to mm
            } else {
                // Cantilever
                if (x <= a) {
                    delta = (P * x * x) / (6 * EI) * (3 * a - x);
                } else {
                    delta = (P * a * a) / (6 * EI) * (3 * x - a);
                }
                
                return delta * 1000; // Convert to mm
            }
        }
        
        // Draw the beam
        function drawBeam() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const { R1, R2, M_max } = calculateReactions();
            
            // Drawing parameters
            const margin = 80;
            const beamY = canvas.height / 2;
            const beamStartX = margin;
            const beamEndX = canvas.width - margin;
            const beamLength = beamEndX - beamStartX;
            const scale = beamLength / L;
            
            // Calculate load position in pixels
            const loadX = beamStartX + loadPosition * beamLength;
            
            // Draw original beam (thin gray line)
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(beamStartX, beamY);
            ctx.lineTo(beamEndX, beamY);
            ctx.stroke();
            
            // Calculate and draw deflected shape
            const deflectionScale = 50; // Exaggeration factor
            const numPoints = 100;
            let maxDeflection = 0;
            
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i <= numPoints; i++) {
                const x = (i / numPoints) * L;
                const deflection = calculateDeflection(x);
                maxDeflection = Math.max(maxDeflection, Math.abs(deflection));
                
                const pixelX = beamStartX + (x / L) * beamLength;
                const pixelY = beamY + deflection * deflectionScale;
                
                if (i === 0) {
                    ctx.moveTo(pixelX, pixelY);
                } else {
                    ctx.lineTo(pixelX, pixelY);
                }
            }
            ctx.stroke();
            
            // Draw beam rectangle
            ctx.fillStyle = '#333';
            ctx.fillRect(beamStartX, beamY - 15, beamLength, 30);
            
            // Draw supports
            ctx.fillStyle = '#27ae60';
            ctx.strokeStyle = '#27ae60';
            ctx.lineWidth = 3;
            
            if (supportType === 'simple') {
                // Left support (pin)
                ctx.beginPath();
                ctx.arc(beamStartX, beamY, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Left support triangle
                ctx.beginPath();
                ctx.moveTo(beamStartX, beamY + 12);
                ctx.lineTo(beamStartX - 15, beamY + 35);
                ctx.lineTo(beamStartX + 15, beamY + 35);
                ctx.closePath();
                ctx.fill();
                
                // Right support (roller)
                ctx.beginPath();
                ctx.arc(beamEndX, beamY, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Right support circles (roller)
                ctx.beginPath();
                ctx.arc(beamEndX - 10, beamY + 25, 6, 0, Math.PI * 2);
                ctx.arc(beamEndX + 10, beamY + 25, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Ground line
                ctx.beginPath();
                ctx.moveTo(beamStartX - 25, beamY + 40);
                ctx.lineTo(beamEndX + 25, beamY + 40);
                ctx.stroke();
            } else {
                // Fixed support (cantilever)
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(beamStartX - 20, beamY - 40, 20, 80);
                
                // Hatch pattern for fixed support
                ctx.strokeStyle = '#1e8449';
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    const y = beamY - 40 + i * 10;
                    ctx.beginPath();
                    ctx.moveTo(beamStartX - 20, y);
                    ctx.lineTo(beamStartX - 30, y + 10);
                    ctx.stroke();
                }
            }
            
            // Draw point load
            ctx.strokeStyle = '#e67e22';
            ctx.fillStyle = '#e67e22';
            ctx.lineWidth = 3;
            
            // Load arrow
            ctx.beginPath();
            ctx.moveTo(loadX, beamY - 80);
            ctx.lineTo(loadX, beamY - 20);
            ctx.stroke();
            
            // Arrow head
            ctx.beginPath();
            ctx.moveTo(loadX, beamY - 20);
            ctx.lineTo(loadX - 8, beamY - 35);
            ctx.lineTo(loadX + 8, beamY - 35);
            ctx.closePath();
            ctx.fill();
            
            // Load label
            ctx.fillStyle = '#000';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`P = ${P} kN`, loadX, beamY - 90);
            
            // Draw reactions
            ctx.fillStyle = '#27ae60';
            ctx.font = 'bold 12px Arial';
            
            if (supportType === 'simple') {
                // R1 arrow
                ctx.strokeStyle = '#27ae60';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(beamStartX, beamY + 60);
                ctx.lineTo(beamStartX, beamY + 45);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(beamStartX, beamY + 45);
                ctx.lineTo(beamStartX - 5, beamY + 55);
                ctx.lineTo(beamStartX + 5, beamY + 55);
                ctx.closePath();
                ctx.fill();
                
                ctx.fillText(`R₁ = ${R1.toFixed(2)} kN`, beamStartX, beamY + 80);
                
                // R2 arrow
                ctx.beginPath();
                ctx.moveTo(beamEndX, beamY + 60);
                ctx.lineTo(beamEndX, beamY + 45);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(beamEndX, beamY + 45);
                ctx.lineTo(beamEndX - 5, beamY + 55);
                ctx.lineTo(beamEndX + 5, beamY + 55);
                ctx.closePath();
                ctx.fill();
                
                ctx.fillText(`R₂ = ${R2.toFixed(2)} kN`, beamEndX, beamY + 80);
            } else {
                ctx.fillText(`R = ${R1.toFixed(2)} kN`, beamStartX, beamY + 60);
            }
            
            // Draw dimensions
            ctx.strokeStyle = '#555';
            ctx.fillStyle = '#555';
            ctx.lineWidth = 1;
            ctx.font = '12px Arial';
            
            // Length dimension
            const dimY = beamY - 120;
            ctx.beginPath();
            ctx.moveTo(beamStartX, dimY);
            ctx.lineTo(beamEndX, dimY);
            ctx.stroke();
            
            // End ticks
            ctx.beginPath();
            ctx.moveTo(beamStartX, dimY - 5);
            ctx.lineTo(beamStartX, dimY + 5);
            ctx.moveTo(beamEndX, dimY - 5);
            ctx.lineTo(beamEndX, dimY + 5);
            ctx.stroke();
            
            ctx.textAlign = 'center';
            ctx.fillText(`L = ${L} m`, (beamStartX + beamEndX) / 2, dimY - 10);
            
            // Distance to load
            ctx.fillText(`a = ${(loadPosition * L).toFixed(2)} m`, (beamStartX + loadX) / 2, dimY + 20);
            
            // Update results
            const deflectionAtLoad = calculateDeflection(loadPosition * L);
            
            document.getElementById('r1Result').textContent = R1.toFixed(2);
            document.getElementById('r2Result').textContent = R2.toFixed(2);
            document.getElementById('maxMoment').textContent = M_max.toFixed(2);
            document.getElementById('maxDeflection').textContent = maxDeflection.toFixed(2);
            document.getElementById('shearLoad').textContent = (supportType === 'simple' ? R1 : P).toFixed(2);
            document.getElementById('deflectionLoad').textContent = Math.abs(deflectionAtLoad).toFixed(2);
        }
        
        // Initialize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    </script>
</body>
</html>